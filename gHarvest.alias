embed
<drac2>

###############################################################################
# SETUP & ARGUMENTS
###############################################################################
args = &ARGS&
arcanum = "arcanum" in args
ignore_cost = "-i" in args
spell_level = 6
level_arg = None
effect_choice = "None"
target = None
valid_effects = ["clumsiness", "fatiguing", "vampiric", "weakness", "withering"]
help_flag = "help" in args

ch = character()
r = name
c = combat()
C = c.get_combatant(r) if c else None

thp_arg = None
rr = 1                # default multiplier for withering dice
die_type = "d6"       # default withering die
spell_name = "Grim Harvest"

# If the character has a spellbook, use it; otherwise fallback
spell_dc = ch.spellbook.dc if ch.spellbook else 10
spell_mod = ch.spellbook.spell_mod if ch.spellbook else 0

# Default messages (final T, D, F).
T = None
D = None
F = "!gHarvest | @theuxguy - https://ko-fi.com/theuxguy"

grim_harvest_default_desc = (
    "You reap the life force of a dying creature and use it to empower the next spell you cast. "
    "Your target must be at 0 hit points and dying or must have died within the last round. If the target is dying, "
    "it must succeed on a Constitution saving throw or die. The next time you cast a spell, you gain 1d10 + your "
    "spellcasting ability modifier in temporary hit points and can choose one of the following effects to inflict on "
    "the target in addition to the usual effects of the spell you are casting. If you do not cast another spell within "
    "1 minute of casting this one, the effect is lost."
)

documentation = (
    f"**{spell_name} Documentation**\n\n"
    "Usage: `!gHarvest [options] [effect] -t <target>`\n"
    "- No arguments: shows this help.\n"
    "- Must be in combat.\n\n"
    f"**Effects:** {', '.join(valid_effects)}\n\n"
    "**Options:**\n"
    "- `-l <level>` (min 6) Set spell level\n"
    "- `arcanum` Use Mystic Arcanum slot\n"
    "- `-i` Ignore slot/arcanum cost\n"
    "- `-t <target>` Set target\n\n"
    "*withering* \n- `-die <die type>` (default d6) \n- `-rr <#>` number of hits from a single cast (e.g. hits with eldritch blast).\n"
    "*vampiric:* \n- `-dmg <amount>` damage applied to one target | half will be used for THP.\n\n"
    "Steps:\n"
    "1. **One-Step**: `!gHarvest <effect> -t <target> [options]` can cast + apply in one go.\n"
    "2. **Two-Step**:\n"
    f"   - `!gHarvest -t <dying target> [options]` to cast **{spell_name}** and gain the effect on caster for 10 rounds.\n"
    "   - Then `!gHarvest -t <target> <effect> [options]` to apply that effect & gain THP.\n\n"
)

# Simple effect descriptions
cond_gHarvest_desc = "You have reaped the life force of a dying creature and can empower your next spell."
cond_clumsiness_desc = f"Speed halved; disadvantage on DEX checks/saves; CON save DC {spell_dc} at end of each turn to end effect."
cond_weakness_desc = f"Deals minimum melee damage; CON save DC {spell_dc} at end of each turn to end effect."
cond_exhaustion_desc = "Exhaustion is cumulative. You die at 6 levels. Speed is reduced by 5 ft per level of Exhaustion."

# Embedded effect descriptions
effect_desc_clumsiness = "**Clumsiness.** Your target's speed is halved for 1 minute, and it has disadvantage on Dexterity ability checks and saving throws. At the end of each of its turns, it can make a Constitution saving throw. If it succeeds, the effect ends."
effect_desc_fatiguing = "**Fatiguing.** Your target must make a Constitution saving throw, gaining 1d4 levels of exhaustion on a failed save or 1 level of exhaustion on a successful one."
effect_desc_vampiric = "**Vampiric.** You recover a number of hit points equal to half the damage you dealt. If you dealt damage to multiple creatures, you recover half the amount of damage you dealt to one of the targets."
effect_desc_weakness = "**Weakness.** The target deals the minimum possible damage on melee attacks, if it hits, for 1 minute. At the end of each of its turns, it can make a Constitution saving throw. If it succeeds, the effect ends."
effect_desc_withering = "**Withering.** You deal an extra 4 dice of damage of the same type as the damage dice of the spell and all damage dealt by your spell becomes necrotic damage."

# Default D embeds
reaped_desc = ""
thp_adjust_msg = ""
result_msg = ""
effect_desc = ""
one_step = ""
result_hp_str = ""
default_desc = grim_harvest_default_desc
ig_cast = ""
arc_cast = ""
spell_cast = ""
resource_str = ""

###############################################################################
# Parsing Additional Args
###############################################################################
i = 0
while i < len(args):
    arg = args[i].lower()
    if arg == "-l" and i+1 < len(args) and args[i+1].isdigit():
        level_arg = int(args[i+1])
        spell_level = max(6, int(args[i+1]))    # or min(6, int(args[i+1])) if you want capping at 6
        i += 2
        continue
    elif arg == "-t" and i+1 < len(args):
        target = args[i+1]
        i += 2
        continue
    elif arg == "-dmg" and i+1 < len(args) and args[i+1].isdigit():
        thp_arg = int(args[i+1])
        # thp_arg = math.floor(int(args[i+1])/2)
        i += 2
        continue
    elif arg == "-die" and i+1 < len(args):
        die_type = args[i+1]
        i += 2
        continue
    elif arg == "-rr" and i+1 < len(args) and args[i+1].isdigit():
        rr = max(1, int(args[i+1]))
        i += 2
        continue
    else:
        # if it's a valid effect and none chosen yet, store it
        if effect_choice == "None" and arg in valid_effects:
            effect_choice = arg
        i += 1

effect_choice_lower = effect_choice.lower()

###############################################################################
# Reusable Subroutines
###############################################################################
def do_cumulative_exhaustion(t, con_save_total, dc):
    """ On success => +1 exhaustion; on fail => +1d4+1. 
        We parse existing 'Exhaustion: X' to accumulate. """
    ex_eff = t.get_effect("Exhaustion")
    new_total = 0
    if ex_eff:
        old_name = ex_eff.name
        if ":" in old_name:
            try:
                old_val = int(old_name.split(":")[1].strip())
                new_total = old_val
            except:
                pass
        t.remove_effect(old_name)

    if con_save_total >= dc:
        new_total += 1
        return new_total
        
    else:
        inc = vroll("1d4+1")
        roll_str = str(inc)
        new_total += inc.total
        return new_total, roll_str

def apply_fatiguing(t, dc):
    """ Force a con save, add exhaustion. """
    con_save = t.save("con")          # or t.saving_throw("con",dc) if you have such method
    roll_str = ""
    result_hp_str = ""
    hp_str = ""

    new_total, roll_str = do_cumulative_exhaustion(t, con_save.total, dc)

    if con_save.total >= dc:
        fat_result = f"\n**{t.name}**\n**CON Save:** {con_save}; Success!\n**DC:** {dc}\n**Exhaustion:** +1 level\n**Effect:** {new_total} exhaustion levels, ({cond_exhaustion_desc})"
        
    elif con_save.total < dc:
        fat_result = f"\n**{t.name}**\n**CON Save:** {con_save}; Failure!\n**DC:** {dc}\n**Exhaustion:** +{roll_str} levels\n**Effect:** {new_total} exhaustion levels, ({cond_exhaustion_desc})"
        
    if new_total >= 6:
        t.set_hp(0) 
        t.set_temp_hp(0)
        hp_str = t.hp_str()
        result_hp_str = f"{t.name}: {hp_str}\n"
        t.add_effect(f"Exhaustion: {new_total}", desc=f"<Dead> {cond_exhaustion_desc}")

    else:
        # re-add
        t.add_effect(f"Exhaustion: {new_total}", desc=cond_exhaustion_desc)
    
    final_msg = fat_result

    return final_msg, result_hp_str

def apply_withering(t, rr, die_type):
    """ immediate necrotic damage => +4 dice. """

    # roll and apply damage to target
    damage_roll = t.damage(f"{4*rr}{die_type}[necrotic]")

    # output strings for result
    result_msg = (
        f"\n**{t.name}**\n"
        f"{damage_roll.damage}"
    )
    hp_str = t.hp_str()
    result_hp_str = f"{t.name}: {hp_str} (-{damage_roll.total})\n"
    return result_msg, result_hp_str

def resource_checks(ch, arcanum, spell_level):
    """ Attempt to consume resources unless ignoring cost. Returns (T, D, success_bool, resource string). """
    # If ignoring cost, skip
    if ignore_cost:
        ig_cast = ""
        resource_str = ig_cast
        return None, None, True, resource_str

    if arcanum and not any(a == "-l" for a in args):
        # check for a custom counter
        cc_name = f"Mystic Arcanum (Level {spell_level} Spell): {spell_name}"
        if not ch.cc_exists(cc_name):
            return f"{ch.name} fails to cast {spell_name}", f"No custom counter named {cc_name}.", False, resource_str
        elif ch.get_cc(cc_name) <= 0:
            return f"{ch.name} fails to cast {spell_name}", f"No uses left for {cc_name}.", False, resource_str
        else:
            ch.mod_cc(cc_name, -1)
            arc_cast = f"\n{cc_name}\n{ch.cc_str(cc_name)} (-1)"
            resource_str = f"{arc_cast}\n"
            return None, None, True, resource_str

    # Normal slot usage
    if ch.spellbook:
        slots = ch.spellbook.get_slots(spell_level)
        has_spell = ch.spellbook.find(spell_name)
        if (slots < 1 and level_arg is None) or (slots < 1 and level_arg > 6):
            return f"{ch.name} fails to cast {spell_name}", f"No level {spell_level} spell slots available.", False, resource_str
        elif not has_spell:
            return f"{ch.name} fails to cast {spell_name}", f"No {spell_name} found in spellbook.", False, resource_str
        elif level_arg is not None and level_arg < 6:
            return f"{ch.name} fails to cast {spell_name}", f"{spell_name} is a level 6 spell.", False, resource_str
        else:
            if not ch.spellbook.get_slots(spell_level):
                return f"{ch.name} fails to cast {spell_name}", f"Failed to use a level {spell_level} slot.", False, resource_str
            else:
                lvl_slots = ch.spellbook.get_slots(spell_level)
                
                if lvl_slots:
                    ch.spellbook.use_slot(spell_level)
                    spell_cast = f"\n**Spell Slots**\n{ch.spellbook.slots_str(spell_level)} (-1)"

                    resource_str = f"{spell_cast}\n"
                return None, None, True, resource_str
    else:
        # no spellbook
        return f"{ch.name} tries to cast {spell_name}", "No spellbook found to consume a slot.", False, resource_str

def create_grim_harvest_effect(C):
    """ Minimal GH effect on caster. """
    if not C.get_effect("Grim Harvest"):
        C.add_effect("Grim Harvest", duration=10, desc=cond_gHarvest_desc)

def apply_child_effect(effect_choice, t, spell_dc):
    """ One-step child effect logic. Returns final text describing the effect. """
    final_text = ""
    result_hp_str = ""
    if effect_choice == "clumsiness":
        clumsiness_button=[{"label":"Clumsiness (End of Turn)","automation":[{"type":"target","target":"self","effects":[{"type":"save","stat":"con","fail":[{"type":"text","text":f"{t.name} is still clumsy!"}],"success":[{"type":"remove_ieffect"},{"type":"text","text":f"{t.name} resists clumsiness!"}],"dc":spell_dc}]}],"verb":"tries to resist clumsiness","style":"4"}]
        t.add_effect("Clumsiness", duration=10, desc=cond_clumsiness_desc, buttons=clumsiness_button)
        effect_desc = effect_desc_clumsiness
        final_text = f"\n**{t.name}**\n**Effect:** Clumsiness, [10 rounds] ({cond_clumsiness_desc})"
    elif effect_choice == "weakness":
        weakness_button=[{"label":"Weakness (End of Turn)","automation":[{"type":"target","target":"self","effects":[{"type":"save","stat":"con","fail":[{"type":"text","text":f"{t.name} is still weakened!"}],"success":[{"type":"remove_ieffect"},{"type":"text","text":f"{t.name} resists weakness!"}],"dc":spell_dc}]}],"verb":"tries to resist weakness","style":"4"}]
        t.add_effect(effect_choice.capitalize, duration=10, desc=cond_weakness_desc, buttons=weakness_button)
        effect_desc = effect_desc_weakness
        final_text = f"\n**{t.name}**\n**Effect:** Weakness, [10 rounds] ({cond_weakness_desc})"
    elif effect_choice == "fatiguing":
        effect_desc = effect_desc_fatiguing
        final_msg, result_hp_str = apply_fatiguing(t, spell_dc)
        final_text = final_msg
    elif effect_choice == "vampiric":
        effect_desc = effect_desc_vampiric
        final_text = thp_adjust_msg
    elif effect_choice == "withering":
        # immediate damage
        effect_desc = effect_desc_withering
        result_msg, result_hp_str = apply_withering(t, rr, die_type)
        final_text = result_msg

    return final_text, effect_desc, result_hp_str

def draft_final_embed(T, D, F):
    """ Draft the final embed. """
    return f"{{'title': '{T}', 'desc': '{D}', 'footer': '{F}'}}"

def thp_logic(ch, thp_arg):
    # apply effect logic
    thp_adjust_msg = "THP Adjust error"
    add_temp_hp = vroll(f"1d10+{spell_mod}")
    current_thp = ch.temp_hp or 0
    thp_effect_msg = "THP Adjust error"
    thp_arg = floor(thp_arg / 2) if thp_arg else None

    if thp_arg is not None and effect_choice_lower == "vampiric":
        if thp_arg > current_thp and thp_arg > add_temp_hp.total:
            temp_delta = thp_arg - current_thp
            ch.set_temp_hp(thp_arg)
            thp_effect_msg = f"\n**Vampiric THP:** {thp_arg}\n**Vampiric Effect:** {ch.name} <{thp_arg} temp HP>; +{temp_delta}  Increase!"
            current_thp = thp_arg
        else:
            thp_effect_msg = f"\n**Vampiric THP:** {thp_arg}\n**Effect:** {ch.name} <{current_thp} temp HP>; No change"
            pass

    elif add_temp_hp.total > current_thp:
        temp_delta = add_temp_hp.total - current_thp
        ch.set_temp_hp(add_temp_hp.total)
        thp_effect_msg = f"\n**Effect:** {ch.name} <{add_temp_hp.total} temp HP>; +{temp_delta}  Increase!"

    else:
        thp_effect_msg = f"\n**Effect:** {ch.name} <{current_thp} temp HP>; No change"

    thp_adjust_msg = f"**{ch.name}**\n**THP:** {str(add_temp_hp)}{thp_effect_msg}\n"

    return thp_adjust_msg

###############################################################################
# MAIN LOGIC
###############################################################################
if not c or not C:
    T = f"{spell_name}"
    D = f"You must be in an active combat to use {spell_name}.\n\n{documentation}"
else:
    # If no arguments, show help
    if len(args) == 0 or help_flag:
        T = f"{spell_name} Help"
        D = documentation
    else:
        # Check if GH is already active
        gh_active = C.get_effect("Grim Harvest") is not None

        # If GH is already active, skip resource checks
        if gh_active:
            # If user provided effect+target => apply effect
            if (effect_choice_lower in valid_effects and target) or (effect_choice_lower == "vampiric" and target is None and thp_arg):
                t = c.get_combatant(target)
                if not t and effect_choice_lower != "vampiric":
                    T = f"{ch.name} tries {spell_name}"
                    D = f"Target '{target}' not found in combat."
                else:
                    # remove GH from caster
                    if C.get_effect("Grim Harvest"):
                        C.remove_effect("Grim Harvest")

                    # child effect
                    # roll THP
                    thp_str = thp_logic(ch, thp_arg)
                    final_text, effect_desc, result_hp_str = apply_child_effect(effect_choice_lower, t, spell_dc)


                    T = f"{ch.name} uses {spell_name}!"
                    D = (
                        f"{thp_str}"
                        f"**Grim Harvest** removed.\n"
                        f"{final_text}\n\n"
                        f"{default_desc}\n\n"
                        f"{effect_desc}\n"
                        f"{resource_str}"
                    )

            else:
                # GH active, but no effect/target => message
                T = f"{ch.name} already has {spell_name}"
                D = "You didn't provide a valid effect or target."
        else:
            # GH not active => do resource checks unless ignoring cost
            Tres, Dres, success, resource_str = resource_checks(ch, arcanum, spell_level)
            # if Tres is not None and Dres is not None and effect_choice_lower != "vampiric":
            if Tres is not None and Dres is not None:
                # resource check might have failed
                T = Tres
                D = Dres
            else:
                # resource check passed or ignoring cost
                # if effect+target => one-step usage
                if (effect_choice_lower in valid_effects and target) or (effect_choice_lower == "vampiric" and target is None and thp_arg):
                    t = c.get_combatant(target)
                    if not t and effect_choice_lower != "vampiric":
                        T = f"{ch.name} attempts {spell_name}"
                        D = f"Target '{target}' not found in combat."
                    else:
                        # no GH effect on caster, immediate effect
                        thp_str = thp_logic(ch, thp_arg)
                        final_text, effect_desc, result_hp_str = apply_child_effect(effect_choice_lower, t, spell_dc)

                        T = f"{ch.name} casts {spell_name} in one-step usage!"
                        D = (
                            f"{thp_str}"
                            f"{final_text}\n\n"
                            f"{default_desc}\n\n"
                            f"{effect_desc}\n"
                            f"{resource_str}"
                        )
                else:
                    # No effect => normal GH creation
                    create_grim_harvest_effect(C)
                    target_str = ""
                    if target is not None:
                        t = c.get_combatant(target)
                        target_str = f" **{t.name}'s** soul is reaped\n"

                    T = f"{ch.name} casts {spell_name}!"
                    D = (
                        f"{target_str}"
                        f"**{spell_name}** is active! Once you choose a valid effect and a target, "
                        f"you'll gain temp HP and apply that effect.\n\n"
                        f"{grim_harvest_default_desc}\n\n"
                        f"Current chosen effect: **{effect_choice}**\n"
                        f"{resource_str}"
                    )

footer = result_hp_str + F if result_hp_str else F
</drac2>
-title "{{T if T else spell_name}}"
-desc "{{D if D else documentation}}"
-footer "{{footer}}" -color <color>
-thumb <image>